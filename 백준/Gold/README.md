## 문제 특이사항 정리

</br>

### Puyo Puyo

위에서 아래로 테트리스 처럼 내려오는 문제, 동일 열의 경우 아래에서 부터 점을 찾으면 그 점의 위치 부터 위로 올라가면서 숫자를 찾아서 둘을 교환하고 원래 숫자의 자리에 점으로 바꿈

---

### 이차원 배열과 연산

Comparator Class 생성, Collections.sort(list,Comparator Class);
로 정렬

---

### 마법사 상어와 파이어볼

배열을 넘어가도 그 다음으로 연결 되는 경우 생각 

---

### 테크로미노

ㅗ모양의 경우 완전탐색 불가능, cnt가 2일때 현재위치에서 4방탐색, cnt가 3일때 현재 위치를 그대로 넘겨줌 -> ㅗ, ㅏ , ㅓ , ㅜ 모두 가능해짐


---

### 드래곤커브
Right,Up,Left,Down -> 90도 회전하게 되면 idx+1%4로 변경된다.
x,y 입력값의 경우 배열로 구현하게 되면 반대로 y,x로 된다.
시작점도 true해줘야 한다.


---

### ZOAC
visit배열로 이전 값을 기억해서 이전 String에서 문자 하나만 추가해서 가장 작은 문자열을 찾는 방법으로 시간 줄였음


---

### 거울
거울이 빛을 쏘는 방향과 나갈 때 몇번 구멍인지 확인해야했음, 나는 1~2*N+2*M 까지의 좌표와 빛의 방향을 list에 넣고 탐색후에 2차원 배열의 크기에 벗어나면 빛의 방향을 바꿔준뒤에 최종 list에 넣었음
<br>
다른 사람은 2차원 배열의 크기를 2+N,2+M으로 설정해서 각 구멍에 맞는 구멍번호를 넣어주고(거울은 -1로 변경) 빛을 쏜뒤 구멍에 번호가 나타나면 탐색종료를 하는 식으로 풀이한듯

---

### AC
String으로 배열문자열을 받고 앞뒤를 자른뒤에 ,를 기준으로 split해서 String배열을 만들게 되면 ,가 없는경우에도 크기가 1을 가지는 배열이 생성된다.
<br>
이 점을 생각하고 frontIdx와 backIdx를 사용하는데 둘이 겹치는 경우는 1개의 문자가 있다, frontIdx>backIdx 인경우에서 1차이가 나면 배열이 비어있다 , 2차이 이상나면 빈 배열에서 빼려고 시도한 것 이기 때문에 error를 출력한다.
